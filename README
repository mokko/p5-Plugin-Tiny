NAME
    Plugin::Tiny - A tiny plugin system for perl

VERSION
    version 0.003

SYNOPSIS
      #in your core
      use Plugin::Tiny; 
      my $ps=Plugin::Tiny->new(); #plugin system
  
      #load plugin_class (and perhaps phase) from your configuration
      $ps->register(
        phase=>$phase,         #optional; defaults to last part of plugin class
        plugin=>$plugin_class, #required
        role=>$role,           #optional
        arg1=>$arg1,           #optional
        arg2=>$arg2,           #optional
      );

      #execute your plugin's methods 
      my $plugin=$ps->get_plugin ($phase); 
      $plugin->do_something(@args);

DESCRIPTION
    Plugin::Tiny is minimalistic plugin system for perl. Each plugin is
    associated with a keyword (referred to as phase). A limitation of
    Plugin::Tiny is that each phase can have only one plugin.

  Bundles of Plugins
    You can still create bundles of plugins if you hand the plugin system
    down to the (bundeling) plugin. That way, you can load multiple plugins
    for one phase (you still need distinct phase labels for each plugin).

      #in your core
      use Moose; #optional
      has 'plugins'=>(
        is=>'ro',
        isa=>'Plugin::Tiny', 
        default=>sub{}
      );

      $self->plugins->register(
        phase=>'Scan', 
        plugin=>'Plugin::ScanBundle', 
        plugins=>$self->plugins, #plugin system
      );

      #in Plugin::ScanBundle
      has 'plugins'=>(is=>'ro', isa=>'Plugin::Tiny', required=>1); 
      $self->plugins->register (plugin=>'Plugin::Scan1'); 
      $self->plugins->register (plugin=>'Plugin::Scan2'); 
  
      my $scan1=$self->plugins->get('Scan1');
      $scan1->do_something(@args);

  Require a Plugin Role
    You may want to do a plugin role for all you plugins, e.g. to
    standardize an interface etc.

ATTRIBUTES
  debug
    expects a boolean. Prints additional info to STDOUT.

  prefix
    Optional init argument. You can have the prefix added to all plugin
    classes you register so save some typing and force plugins in your
    namespace:

      #without prefix  
      my $ps=Plugin::Tiny->new  
      $ps->register(plugin='Your::App::Plugin::Example1');
      $ps->register(plugin='Your::App::Plugin::Example2');

      #with prefix  
      my $ps=Plugin::Tiny->new (  prefix=>'Your::App::Plugin::' );  
      $ps->register(plugin='Example1');
      $ps->register(plugin='Example2');

  role
    Optional init argument. A default role to be applied to all plugins. Can
    be overwritten in register.

METHODS
  $ps->register(phase=>$phase, plugin=>$plugin_class);
    Registers a plugin, e.g. uses it and makes a new plugin object. Needs a
    plugin. If you don't specify a phase it, it uses a default phase from
    the plugin class name. See method "default_phae" for details.

    Optionally, you can also specify a role which your plugin will have to
    be able to apply. Specify role=>undef to unset global roles.

    Remaining key value pairs are passed down to the plugin constructor:

      $plugin_system->register (
        plugin=>$plugin_class,   #required
        phase=>$phase,           #optional
        role=>$role,             #optional
        plugins=>$plugin_system, #optional
        args=>$more_args,        #optional
      );

    A side-effect is that your plugin cannot use 'phase', 'plugin', 'role'
    as named arguments.

    Returns the newly created plugin object on success. Confesses on error.

  $plugin=$ps->get_plugin ($phase);
    Returns the plugin object associated with the phase. Returns undef if no
    plugin is registered for this phase.

  $ps->defaultPhase ($plugin_class);
    Makes a default phase from a class name. If prefix is defined it use
    tail minus '::'. Otherwise just last element of the class name.

    For My::Plugin::Long::Example and prefix='My::Plugin::' this results in
    'Long::Example' and without prefix it would be 'Example'.

    Returns scalar;

  $class=$ps->get_class ($plugin);
    returns the plugin's class. A bit like "ref $plugin". Not sure what it
    returns on error. Todo!

  $phase=$ps->get_phase ($plugin);
    returns the plugin's phase. Returns undef on failure. Normally, you
    should not need this.

AUTHOR
    Maurice Mengel <mauricemengel@gmail.com>

COPYRIGHT AND LICENSE
    This software is copyright (c) 2012 by Maurice Mengel.

    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.

